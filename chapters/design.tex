

\paragraph{} In this chapter we shall introduce and detail a prototype implementation of a modular, SGX-protected \textit{reference monitor} --- \textsc{Citadel}. First we motivate its necessity and discuss the challenges faced. Then, the three-part architecture will be explained, relating various design decisions to the DIFC model it provides. A discussion about the architecture's performance and effectiveness is provided in §~\ref{sec:eval}.

\section{Motivation}
\paragraph{} Since its introduction in a 1972 report from Anderson,~\cite{reference-monitor} the reference monitor concept has time and again proved to be a reliable workhorse for a plethora of security models. It does not refer to any exact policy, nor limit itself to any particular implementation --- it's abstractness is one of its greatest strengths, reserving any judgement about what policy is \textit{appropriate} in a particular setting.~\cite{irvine-rm}

\paragraph{Fundamental Properties of a Reference Monitor}

\begin{itemize}
    \item \textit{Always invoked.} Every access to the system must be mediated to guarantee that adversaries are unable to bypass the system's security policies.
    \item \textit{Evaluable.} It ``must be small enough to be subject to analysis and tests, the completeness of which can be assured'';~\cite{reference-monitor} to be trustworthy, it must be \textit{auditable}, with, ideally, a restricted TCB.
    \item \textit{Tamper proof.} To ensure that an attacker cannot disable the authorisation mechanisms mandated by the security policy, the integrity of a reference monitor cannot be in question.
\end{itemize}

\paragraph{} No computer system is ever completely secure, and Linux is no exception. Having grown by 1.7 million lines of code (LoC) in the past year alone, to stand at 27.8 million LoC in total,\footnote{\url{https://www.theregister.com/2020/01/06/linux\_2020\_kernel\_systemd\_code/}} bugs are inevitable --- almost 2000 have been reported in the past year,\footnote{\url{https://bugzilla.kernel.org/}} and 662 \textit{severe} bugs are still outstanding.\footnote{\url{https://www.cvedetails.com/product/47/Linux-Linux-Kernel.html}} In this context we must question whether Linux alone can provide a reference monitor implementation the guarantees it requires,~\cite{Lipp2018MeltdownRK, 10.5555/2831143.2831164} thus motivating the use of SGX.

\paragraph{} Applying SGX to this problem brings two attractive benefits;
\begin{itemize}
    \item The system's IFC policy can be evaluable both during offline analysis and online using \textit{attestation}, helping other enclaves' confidence in the underlying system.
    \item SGX's hardware protections are very capable at defending a reference monitor's state, even if adversaries have ring-0 privilege or in the presence of a kernel bug.
\end{itemize}

\section{Challenges}

\begin{figure}[]
    \centering
    \includegraphics[width=0.48\linewidth]{figures/SGX-EnclaveIntegration.pdf}
    \caption{Abstract \textit{syscall} control flow route. Grey components show the natural Linux design. Green additions highlight the externalised enclave LSM component.}
    \vspace{5mm}
    \label{fig:sgx-abstract-integration}
\end{figure}

\paragraph{} The natural location for a reference monitor is embedded directly in the kernel, in the path of \textit{syscalls'} control flows. \textit{CamFlow} does exactly this using the LSM framework, silently tagging processes and other entities as they are encountered by the kernel, additionally providing an external LSM-interface for any active changes. An SGX enclave is incompatible with this workflow however (§~\ref{sec:sgx-no-kernel-mode}), as it cannot execute alongside kernel code. Thus a major, unavoidable design decision is that the reference monitor must be distributed across rings 0 and 3 --- an enclave \textit{policy} component, and an LSM for \textit{enforcement}.

\paragraph{} The disruption this change causes could severely impact performance; Figure~\ref{fig:sgx-abstract-integration} highlights the significant change to overall control flow. Most notably, externalising part of the LSM to an enclave forces, in the worst case, an additional pair of context switches for each \textit{syscall}.

\paragraph{} Given a ring-3 component is unavoidable, the question becomes how to minimise the overhead caused by its integration, all while maintaining \textit{safety} (every operation must be mediated). This problem is reminiscent of the ones that inspired the development of \textit{exokernels}~\cite{10.1145/224056.224076} --- both the drawbacks and opportunities of those approaches apply here.~\cite{10.1145/269005.266644} \textcolor{red}{More detail about why.}

\paragraph{} Two architectures, as illustrated in Figure~\ref{fig:sgx-integration}, were initially considered. 

\begin{enumerate}
    \item An \textit{isolated} extension of the LSM. Only the security implementation communicates with the \textit{policy} enclave, acting as a na\"{i}ve reimplementation of a fully self-contained LSM, and using an additional kernel module as an I/O relay.
    \item An \textit{integrated} userspace service, through which permission is \textit{requested} ahead of time and decisions stored in the LSM before being needed. Back flow of information is facilitated asynchronously, but an additional kernel relay is not required.
\end{enumerate}



\begin{figure}[]
    \centering
    \includegraphics[width=0.98\linewidth]{figures/SGX-EnclaveIntegration-Design}
    \caption{}
    \vspace{2mm}
    \label{fig:sgx-integration}
    \vspace{5mm}
\end{figure}

\paragraph{}\textit{Architecture 1} can be implemented without changing the base IFC model presented in §~\ref{sec:ifc-modelling}, easing potential concerns regarding correctness and safety. However it adds significant overhead to the critical sections~\cite{Dubois1988SynchronizationCA} of core LSM functions, in most cases while the kernel holds locks for various objects being accessed.

\paragraph{} \textit{Architecture 2} is more flexible, requiring all negotiation be conducted ahead of time, and importantly, without leaving userspace: any overhead only impacts the application, leaving the kernel's critical sections to execute with minimal interference. A notable downside, however, is that the system's security model will need to be extended to accommodate the fact that \textit{policy decisions and enforcement are no longer one and the same}.

\paragraph{} Preliminary experiments showed that the performance of the two architectures were similar in light workloads, but \textit{Architecture 1} degrades significantly in the presence of any resource contention. Additionally, as will be explained in §~0.0, the dependence on a kernel module conflicts with the desired constrained TCB of the system. For these reasons \textit{Architecture 2} forms the basis of the prototype.

\paragraph{} An additional challenge is one of incomplete information --- an enclave will not be privy to internal kernel datastructures such as \texttt{task\_struct}, which will store the taint and capabilities of processes. A potential solution would be to implement a request---response model via a custom kernel interface for any queries, though the performance impact would be severe, requiring additional context switches. The approach adopted instead (§~0.0) uses inference based on partial information an enclave has. Any solution must be trustworthy and safe, and malicious entities must not be able to exploit any \textit{eventually consistent} components.~\cite{10.1145/1435417.1435432}

\paragraph{} As a final comment, it must be noted that SGX is not without its flaws; §~5.X discusses this and its impact on the project.


% ---------------

\section{The \textsc{Citadel} IFC Model}

\paragraph{} Before work on the final \textsc{Citadel} implementation began, we constructed a formalisation describing the distributed nature of its design. A model helps reason about the safety and correctness of the final system, and provides the notation to properly discuss its features. Our model, which will now be presented, directly extends the one presented in §~\ref{sec:ifc-modelling}.

\subsection{Reservations}

\paragraph{} Previously we had defined the concept of a \textit{safe flow}, $A \rightarrow B$, which underpins the heart of our IFC restrictions. In previous works permission to perform an operation is granted while \textit{implicitly} considering \textit{how} the flow is to take place (\ref{eqn:res-1}). An isolated \textit{enforcement} component does not understand the concept of \textit{flows}, forcing policy decisions to be defined \textit{explicitly}; \textsc{Citadel} uses \textit{reservations} for this purpose (\ref{eqn:res-2}). This distinction is simple but very important when introducing \textit{laziness} and other optimisations between the two halves of the reference monitor.

\begin{equation}\label{eqn:res-1}
    \textit{operation} \rightarrow \boxed{\textit{reference monitor}} \xrightarrow{\;\;\textit{decision}\;\;} \{0,1\}
\end{equation}
\vspace{-3mm}
\begin{equation}\label{eqn:res-2}
    \textit{operation} \rightarrow \boxed{\textit{policy}\; \xrightarrow{\;\;\textit{reservation}\;\;} \;\textit{enforcement}} \xrightarrow{\;\;\textit{decision}\;\;} \{0,1\}
    \vspace{3mm}
\end{equation}


\paragraph{} Let $\Omega$ be the set of all operations mediated by the reference monitor, including, for example, \texttt{file\_read} or \texttt{socket\_open}. Also, let us define $\mathcal{R}$, the set of all \textit{reservations}, as follows.\footnote{Recalling that $\mathcal{T}$ is the set of all tags.}

\newcommand{\powerset}{\raisebox{.15\baselineskip}{\Large\ensuremath{\wp}}}
\vspace{-7mm}
\begin{equation*}
    \mathcal{R} = \mathcal{T} \times \powerset(\Omega)
    \vspace{2mm}
\end{equation*}

\paragraph{} Further, we define a shorthand, $t^{\alpha}$;
\vspace{-3mm}
\begin{equation*}
    r \in \mathcal{R} \;.\; (r = (t, \alpha) = t^{\alpha} \implies t \in \mathcal{T} \; \wedge \; \alpha \subseteq \Omega)
\end{equation*}

\paragraph{} We introduce, for a process $A$, additional state; $A_{r} \subseteq \mathcal{R}$, the set of all reservations it holds. Once a decision has been made, it is important for a reference monitor to be able to change it, revoking access if required. Thus we specify a notion of \textit{validity} with an indicator function, $\mathcal{V}: \mathcal{R} \mapsto \{0,1\}$. A reservation can only be used to obtain access to a resource if it is valid; invalid reservations are discarded.

\subsection{Permissible Operations}
\label{sec:permissible-operations}

\paragraph{Satisfiability} To determine whether an operation may be permitted, the \textit{constraint reservation} representing it is compared against reservations held by the process. As an example, $t^{\{\texttt{file\_read}\}}$ is the constraint for reading a file tagged with $t$.

\paragraph{} A constraint $\tau^{x}$ is said to be satisfied by a reservation $\tau^{y}$ ($\tau^{x} \sprecsim \tau^{y}$) if the tags match, the reservation is valid, and $y$ permits \textit{at least} the required form of access (\ref{eqn:satis-1}). Equations (\ref{eqn:satis-2}) and (\ref{eqn:satis-3}) define set comparison counterparts --- constraint $\tau^{x}$ is satisfied by a set of reservations $y$ ($\tau^{x} \sqin y$), and a set of constraints $\mu$ is satisfied by a set of reservations $\nu$ ($\mu \sqsubseteq \nu$).

\vspace{-5mm}
\begin{align}
    \sigma^{\alpha}, \tau^{\beta} \in \mathcal{R} &\;.\; (\; \sigma^{\alpha} \sprecsim \tau^{\beta} \iff \sigma = \tau \;\wedge\; \alpha \subseteq \beta \;\wedge\; \mathcal{V}(\tau^{\beta}) \;) \label{eqn:satis-1}\\
    \sigma^{\alpha} \in \mathcal{R}, \; x \subseteq \mathcal{R} &\;.\;  (\; \sigma^{\alpha} \sqin x \iff \exists \, \tau^{\beta} \in x \;.\; \sigma^{\alpha} \sprecsim \tau^{\beta} \;) \label{eqn:satis-2}\\
    \mu, \nu \subseteq \mathcal{R} &\;.\;  (\; \mu \sqsubseteq \nu \iff \forall \, \alpha \in \mu \;.\; \alpha \sqin \nu \;) \label{eqn:satis-3}
\end{align}

\paragraph{} From here we define a \textit{permissible operation}, $A \xrightharpoonup{\;\omega\;} t$; process $A$ may perform operations $\omega$ on an entity tagged with $t$. An operation is only permissible if the process holds a reservation explicitly granting permission (\ref{eqn:permissible-op}).
\begin{equation}
    \label{eqn:permissible-op}
    A \xrightharpoonup{\;\omega\;} t \iff (\exists \; t^{\alpha} \in A_r \implies t^{\omega} \sprecsim t^{\alpha})
\end{equation}

\paragraph{} To bridge the gap between permissible flows and operations, a final definition is required; a \textit{specific permissible flow}, $A \,\xmapsto{\;\omega,\tau\;}\, B$, meaning that $A$ may send information to $B$ using operations $\omega$, via entities tagged with $\tau$. Two natural statements fall out from these definitions;

\vspace{-7mm}
\begin{align}
    (\exists\, \omega,\tau \;.\; A \,\xmapsto{\;\omega,\tau\;}\, B) \implies & A \rightarrow B \\
    A \,\xmapsto{\;\omega,\tau\;}\, B \implies & (\exists \,\omega' \;.\; A \xrightharpoonup{\;\omega'\;} \tau \;\land\; \omega \subseteq \omega') \label{eqn:flow-abs-conc-map}
\end{align}

\paragraph{} Together, these define the relationship between an abstract policy space ($A \rightarrow B$, §~\ref{sec:policy-enclave}) and concrete implementation ($A \xrightharpoonup{\;\omega\;} \tau$, §~\ref{sec:enforcement-domain}). As (\ref{eqn:flow-abs-conc-map}) suggests, a policy decision may grant a greater set of permissions than asked for --- e.g. allowing both read and write when only write was explicitly requested.~\cite{flume,Zeldovich2008}

\paragraph{} A handful of small updates are required to make the existing rules consistent with the new: reservations are not transferred when creating a new entity (\ref{eqn:new-creation}), and reservations are not affected by capabilities as they represent a centralised component of the DIFC system. 

\vspace{-5mm}
\begin{equation}
    A \Rightarrow B \implies A_s = B_s \; \wedge \; A_i = B_i \; \wedge \; B_r = \varnothing \label{eqn:new-creation}
\end{equation}


\subsection{Transient Entities}
\label{sec:transient-entities}

\paragraph{} Alongside active and passive entities, we introduce a third type; \textit{transient} entities. These are passive entities that are privately held by an owning active entitiy; they will be used to model Linux functions such as \texttt{pipe()} and unclaimed tainted files.

\paragraph{} To facilitate this, all processes will be assigned a unique tag $p \in \mathcal{T}$, and any files it creates will initially also be tagged with $p$. Using $\mathcal{P}$ as the set of all process identifiers, we define $\mathcal{I}$ as the function returning a process's transient identifier;

\vspace{-5mm}
\begin{equation}
    \mathcal{I}: \mathcal{P} \mapsto \mathcal{T}
\end{equation}

\paragraph{} The modified expression for a \textit{permissible operation} now becomes;

\vspace{-5mm}
\begin{equation}
    A \xrightharpoonup{\;\omega\;} t \iff \mathcal{I}(A) = t \;\lor\; (\exists \; t^{\alpha} \in A_r \implies t^{\omega} \sprecsim t^{\alpha})
\end{equation}

% ---------------
\clearpage
\section{Implementation}

\begin{figure}[]
    \centering
    \includegraphics[width=\linewidth]{figures/OverallArchitecture.pdf}
    \caption{High level overview of the \textsc{Citadel} architecture.}
    \vspace{-5mm}
    \label{fig:citadel-overview}
    \vspace{5mm}
\end{figure}

\paragraph{} \textsc{Citadel} consists of three components; an LSM, \texttt{citadeld}, and \texttt{libcitadel}. Each plays an essential, symbiotic role in the operation of the reference monitor. The prototype required in excess of 9,000 lines of C and C++, and extends the Linux kernel build system (§~\ref{sec:build-system}). This section shall present \textsc{Citadel}'s architecture, guided by Figure~\ref{fig:citadel-overview}.

\paragraph{Analogy} The system is well modelled by the \textit{will-call} system used by theatres and the like --- clients (\textit{processes}) reserve tickets (\textit{permission}) to attend a show (\textit{perform an operation}) ahead of time via phone or the internet (\texttt{citadeld}), but only receive their tickets (\textit{reservations}) at the venue (\textit{LSM}) on the day (\textit{at the point of execution}).

\paragraph{} \textsc{Citadel}'s ring-0 components comprise its \textit{enforcement domain} (§~\ref{sec:enforcement-domain}), and \texttt{citadeld} components its \textit{policy domain} (§~\ref{sec:policy-enclave}). The enforcement domain is \textit{policy-agnostic}, implementing an abstract, tagged taint tracking system that exposes decision points to policy influence via reservations. In contrast, policy components need not be aware of the exact enforcement strategy to successfully express their protection schemes. Communication between the two domains is discussed separately in §~\ref{sec:interdomain-comms}.



\subsection{Enforcement}
\label{sec:enforcement-domain}

\begin{figure}[]
    \centering
    \includegraphics[width=0.55\linewidth]{figures/CitadelTaint.pdf}
    \caption[Accesses across the taint boundary]{Accesses across the taint boundary taint the untainted party.}
    \label{fig:taint-boundary}
\end{figure}

\paragraph{} The \textsc{Citadel} LSM tracks all entities within the Linux system by allocating and attaching a small data structure ($<48$ bytes) to each; it computes and tracks a conservative notion of \textit{taint} for each to ensure \textit{safety}. Tainting in \textsc{Citadel} is dynamic, meaning that entities are only policed if there is a reason. This process is \textit{additive}, only tainting an object if it is involved in a successful operation crossing the taint boundary (Figure~\ref{fig:taint-boundary}); this includes the child process created when a tainted process calls \texttt{fork()}. In additional to automatic propagation, taint for the majority of entities is amendable on request from the policy domain.

\paragraph{} Recalling that entities can either be \textit{active} or \textit{passive}, a variety of metadata is tracked for each.

\begin{enumerate}
    \item[---]\textbf{Active}. The only active entities in Linux are processes --- these require a plethora of markers and flags, including; \textit{taint} and its \textit{reservation list}. The remaining metadata is introduced in §~4.X.
    \item[---] \textbf{Passive}. There are many forms of passive entity, the most prevalent being files and other inode-backed structures. These carry \textit{taint}, an \textit{identifier} (tag), and an \textit{anonymous flag}. Inode tracking is detailed first, with other types of passive entities, such as shared memory, discussed in §~4.X. 
\end{enumerate}

\subsubsection{Identifiers}
\paragraph{} Entities may be tagged with a single identifier; this corresponds to a tag in the IFC model, and are randomly assigned 128-bit numbers. If a security policy wishes to maintain pseudonyms for secrecy and integrity, for example, it may internally, but must convert back to the system tag for enforcement.

\subsubsection{Extended Attributes} 
\paragraph{} An inode-backed entity's taint flag and identifier are copied to \textit{xattrs} attached to it via the VFS. These occupy the \texttt{security.citadel} namespace, and are essential for ensuring that taints and identifiers persist between boots. Certain entities may be \textit{anonymous}, as indicated by their anonymous flag, meaning that their identifier is not present as an \textit{xattr}. This may either be because the entity does not support \textit{xattrs} (such as files created using \texttt{pipe()}) or that the identifier is temporary (§~\ref{sec:entity-creation}).


\subsubsection{Permissions} 
\paragraph{} Tainted processes must hold a valid reservation in their reservation list to perform any operation that may allow data to flow to another entity; the code for this check is attached in Appendix X for reference, but strictly follows the formal rules presented in §~\ref{sec:permissible-operations}. Untainted processes bypass all checks, and thus lie outside the IFC model; the security implications of this are discussed in §~4.X.


\subsubsection{Reservation Cache} 
\paragraph{} When the system's policy domain presents a new reservation to the LSM, it is stored in a structure called the \textit{reservation cache}. Implemented as a red-black tree, it maps a process's identifier to a linked list of its pending reservations. This intermediary storage is necessary as LSMs are event-driven, and thus can only access an entity's state when it is presented for review. Before a permission check is carried out, the LSM ensures that the process's reservation list is up to date by;
\begin{enumerate}
    \item \textit{Installing pending tickets}. All reservations held for the process are moved to its internal reservation list, ready for inspection.
    \item \textit{Disposing of expired entries}. The validity function the LSM uses is time-based. When a reservation is inserted into the reservation cache, it is timestamped with an explicit expiry date --- this lifetime is $15$ seconds by default.  
\end{enumerate}


\subsubsection{Entity Creation}
\label{sec:entity-creation}
\paragraph{} As detailed in §~\ref{sec:transient-entities}, every newly spawned process is privately tagged by the LSM as if it were a passive entity. The purpose of this identifier is not to directly identify the process, but to provide a mechanism for associating any private, passive entities it creates with it. This includes the file descriptors provided by \texttt{pipe()}, and any new files it creates using \texttt{open()}. Every process always has permission to access its transient entities, and external entities can only gain the right to access them if they;
\begin{enumerate}
    \item Are a child processes and request access to their parent, or
    \item The process officially \textit{claims} them via the policy enclave, which gives them an independent tag and removes the entity's status as transient. 
\end{enumerate}


\paragraph{\texttt{fork()}} In Linux, child processes are initially exact clones of their parent, with access to the same state and file descriptors. Thus children of tainted processes are also tainted, but importantly do not assume the same rights as their parents --- open file descriptors will not fucntion without revalidation (§~4.X), and children must request the right to to their parent's transient entities via a special command to use pipes or similar. It is the prerogative of the policy enclave to validate that the security contexts of the parent and child have not diverged. \textcolor{red}{mention leakage through fd state}





\subsection{Policy Components}
\label{sec:policy-enclave}

\paragraph{} The policy counterpart to the LSM's enforcement is contained within \texttt{citadeld}, a userspace service that hosts the core SGX enclave. \texttt{citadeld} is modular, hosting an independent policy module sitting on top of an enforcement translation library (Figure~\ref{fig:policy-enclave}).

\subsubsection{Abstract Policy Module}
\paragraph{} The policy module embedded in \texttt{citadeld} is presented with a simple, event-driven interface that abstracts the reality of enforcement away. Their implementation is based around a single method, through which their permission is sought when required; \texttt{asm\_handle\_request(3)}.


\paragraph{} The simplest possible policy is as follows; any operation between or using any entity is deemed permissible. The request parameter, amongst other things, holds the target identifier and set of operations. 

\begin{minted}[fontsize=\footnotesize]{c}
citadel_response_t asm_handle_request (pid_t pid, 
        struct citadel_op_request *request, void *metadata) {
    return CITADEL_OP_APPROVED;
}
\end{minted}

\begin{figure}[]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/EnclaveLayout.pdf}
    \caption{Overview of the components inside \texttt{citadeld}.}
    \label{fig:policy-enclave}
\end{figure}

\paragraph{} This can be considered to determine the validity of an operation, $A \xrightharpoonup{\;\omega\;} t$, based on its knowledge of any implicated flows ($A \rightarrow *$).

\paragraph{Operations} Entity operations, $\Omega$, are presented as \texttt{citadel\_operation\_t}, a simple bit mask over the operations \textsc{Citadel} recognises (Appendix X). Similarly, policy decisions are represented using \texttt{citadel\_response\_t}; these may be \textit{approved}, \textit{rejected}, \textit{error}, \textit{invalid}, \textit{granted},\footnote{Approved, and confirming that the process is recognised as the owner of the entity.} and \textit{forged}.\footnote{Discussed in §~4.X.}


\subsubsection{Host Application}
\paragraph{} Before requests (§~4.X) are presented to the resident policy module, various steps need to be taken in preparation. Requests often refer to absolute filepaths, creating a need to retrieve their tags, if they exist --- these requests are served by the security \textit{xattrs} attached to the VFS file. Translation is performed preemptively depending on the operation requested, and to minimise any lookup overhead, results are cached in a \textit{translation cache}. This is implemented using \textit{sparsehash},\footnote{\url{https://github.com/sparsehash/sparsehash}} taking great care to detect and remove stale items.


\subsubsection{Enforcement Interface}
\paragraph{} The policy module is interchangeable, but the enforcement interface acts as the backbone of the enclave. All requests are routed through it as a sanitsation step, detecting forgery or and invalid data, and all information leaving it is formatted and signed\footnote{Encryption is discussed in §~\ref{sec:interdomain-comms}} as appropriate. The process of installing reservations created by the enforcement interface, on behalf of the policy module, is detailed in §~\ref{sec:interdomain-comms}.

\subsubsection{\texttt{libtomcrypt}}
\paragraph{} We ported \textit{libtomcrypt},\footnote{\url{https://github.com/libtom/libtomcrypt}} a leading open source cryptography library, to function inside an SGX enclave. This was necessary to support a number of the encryption mechanisms the system requires, on top of those already provided by SGX. This was achieved by replacing its backing precision arithmetic library to be an SGX-aware version of \textit{GMP}\footnote{\url{https://github.com/intel/sgx-gmp}}, and forcing it to statically allocate its memory (as SGXv1 lacks support for dynamic memory management). Further changes rewrote the internal random number generator to use the one provided by SGX, and rework its exception strategy to remove \texttt{abort()}, an illegal instruction inside an enclave.

\subsection{Communication Pathways}
\label{sec:interdomain-comms}
\paragraph{} There are three notable I/O pathways between components within \textsc{Citadel};
\begin{enumerate}
    \item \textsc{Applications $\longleftrightarrow$ Policy Enclave}. \\
    All application requests (via \texttt{libcitadel}, §~\ref{sec:libcitadel}) are sent to the policy enclave using a standard domain socket; \texttt{/run/citadel.socket}. To ensure that all processes have the right to communicate with the reference monitor, a special tag, $\tau = 2^{128} -1$, is assigned to it, asserting the reference monitor's ownership of it and whitelisting it in the LSM.
    \item \textsc{Policy Enclave $\longleftrightarrow$ LSM}. \\
    These parties communicate using two mediums; \textit{SecurityFS} and \textit{xattrs}. All messages between these are encrypted using AES-256-GCM~\cite{Rijndael,McGrew2005TheGM}; the key is chosen during the system's initialisation (§~\ref{sec:initialisation}). \\
    Reservations are installed using a custom \textit{SecurityFS} interface,\footnote{\texttt{/sys/kernel/security/citadel/update}} and are synchronously inserted into the reservation cache. The policy enclave may decide to invoke an operation directly on a file; this is handled by invoking \texttt{setxattr()}, which the LSM intercepts, triggering it to enact the required changes to the entity; the most common use of this method is entity tagging.
    \item \textsc{LSM $\longrightarrow$ Applications}. \\
    To verify their identities with the policy enclave, applications need to present a \textit{ptoken} with each request; this process is described in §~\ref{sec:ptokens}, but can be generated by reading from a globally readable \textit{SecurityFS} interface.\footnote{\texttt{/sys/kernel/security/citadel/ptoken}} \\
    In addition to this, \textit{libcitadel} occasionally needs to check the tag associated with a path or file descriptor; this is managed using the existing \texttt{libc} \textit{xattr} methods.
\end{enumerate}

\subsubsection{Initialisation and Encryption}
\label{sec:initialisation}
\paragraph{} Whenever the system boots, the LSM is always the first to come online --- \texttt{citadeld} may appear at any time beyond this, meaning that the LSM must be capable of operating independently. In this case, when the LSM is isolated, the system will tend towards a state of complete lockdown (for tainted processes). Thus the mechanism by which the LSM and policy enclave initialise communication is vital for secure operation; \textsc{Citadel} achieves this with a pair of 2048-bit RSA keypairs, one for the enclave ($E_{P/S}$) and one for the kernel ($K_{P/S}$).

\paragraph{} SGX does not provide protection against reverse engineering, thus the enclave's keys must be provided to it as a sealed entity; sealing here uses \texttt{MRSIGNER}, allowing any policy enclave provided by the \textit{sealing authority} to fully function, and is compiled into the kernel, available via \textit{SecurityFS}.\footnote{\texttt{/sys/kernel/security/citadel/sealed\_keys}}

\paragraph{} Once a policy enclave has been initialised it must verify itself; the LSM issues a random challenge\footnote{\texttt{/sys/kernel/security/citadel/challenge}} encrypted using the enclave's public key, and expects a reply using the corresponding private key.

\vspace{-5mm}
\begin{align*}
    \text{LSM} \rightarrow \text{Enclave} &: \{\textit{challenge}\}_{E_{P}} \\
    \text{Enclave} \rightarrow \text{LSM} &: \{\textit{challenge}, \textit{PID}, \textit{identifier}, \textit{aes\_key}, ...\}_{E_{S}}
\end{align*}

\paragraph{} Given $E_S$ is only held sealed, any entity providing a valid challenge is trusted, and is considered part of the \textsc{Citadel} TCB. The challenger's PID is stored to detect any adversarial replay messages. RSA is only used for this initial exchange; it would be too slow to use for all messages. Thus the AES key provided in the response forms the basis of all future communication.

\paragraph{} \textsc{Citadel} uses AES to protect sentitive messages as every SGX-capable processor supports \textit{AESNI}~\cite{aesni} to accelerate AES in hardware. SGX provides this natively inside enclaves, and the official \textit{Intel AESNI} driver is included in the mainline kernel. \textit{AESNI} provides an encryption bandwidth in excess of 1 Gbps,\footnote{Our experiments on the evaluation hardware exceeded this, but this value is fair given the large range of processors that support SGX.} far exceeding the capacity required in this system, and thus adding negligable overhead. The system's AES key updates with every message sent from the enclave using an SGX-approved source of entropy;\footnote{$new \leftarrow old \oplus update$} this adds minimal overhead, and constitutes good practice. A copy of the initial key presented in the challenge response is retained and used in cases when a static key is essential.

\subsection{\texttt{libcitadel}}
\label{sec:libcitadel}
\paragraph{} \textsc{Citadel} provides a userspace auxiliay library to make integrating existing programs as effortless as possible. For each mediated \textit{syscall} (e.g. \texttt{open()}), it provides a proxy function (\texttt{c\_open()}): this would, in a future iteration of this design, be integrated directly into \texttt{libc}, but currently requires no major changes to applications' workflows. A good example of this in action is the ported version of \textit{Nginx} (§~5.X).

\paragraph{} \texttt{libcitadel} performs two main functions;
\begin{enumerate}
    \item Communication with the policy enclave.
    \item Tracking and predicting what permissions it believes the process has.
\end{enumerate}

\paragraph{} Communication is facilitated via the UNIX domain socket provided by \texttt{citadeld}. A zero-copy approach\footnote{Of course excluding copying in the kernel and when transferring the request into the enclave.} is used to minimise latency on both sides; this is optimised for in the protocol design, and great effort has been put into minimising the cost of communication here. Each side verifies the PID of the other party, as detailed in §~\ref{sec:ptokens}.

\paragraph{} Caching at this level has a tremendous impact on overall performance. when reading a large file, for example, a program may make thousands of calls to \texttt{c\_read()} on the same file --- making an external call to \texttt{citadel} would be a hude waste, as processes have, in most cases, enough information to infer what their current position may be.

\paragraph{} To this end, every process  maintains a list of \textit{expectations} --- the reservations it believes it has, including their validity --- and whether they have inferred that they have been tainted by the LSM. They cannot exactly know the true values of these, especially as the policy enclave may grant different permissions than asked for, but in \textit{Nginx}, as an example, over 97\% of requests were servable locally in a realistic workload. Using the same workflow, untainted processes speculatively execute operations, again removing the need to involve \texttt{citadeld}. The performance gain of requests served from the cache reduces the overhead from $\mathcal{O}(10\mu s)$ to $\mathcal{O}(100ns)$.


\begin{listing}
\begin{minted}[fontsize=\small]{c}
int c_open(const char *pathname, int oflag, mode_t mode) {
    int fd; bool from_cache = false;
    bool creating = access(pathname, F_OK) < 0 && (oflag & O_CREAT) > 0;
    
    // Pre-emptively attempt access if I suspect I'm not tainted.
    // Alteratively, register a transient file is we're creating it.
    // -- close and reopen to ensure it is independently tagged.
    if (!am_tainted() || creating) {
        fd = open(pathname, oflag, mode);
        if (!am_tainted() && fd > 0)
            return fd;
        if (fd == -1 && errno != -EPERM)
            return -1;
        close(fd);
    }

    // Request access from the policy enclave. Claim file if not tagged.
    if (!citadel_file_open(pathname, strlen(pathname)+1, &from_cache))
        return -EPERM;

    // Continue as normal.
    fd = open(pathname, oflag, mode);
    if (!from_cache) citadel_declare_fd(fd, CITADEL_OP_OPEN);
    if (!am_tainted()) set_taint();
    return fd;
}
\end{minted}
\caption{The \texttt{libcitadel} shim function for \texttt{open()}.}
\label{lst:c_open}
\end{listing}

\paragraph{} A core challenge of the cache is relating open file descriptors to the permissions they require. This at points requires some manual work, including fetching its \textit{xattr} tag with \texttt{fgetxattr()} and estimating the expiration time of the LSM's underlying reservation. Ideally \texttt{libcitadel} requests revalidation just before expiry to ensure no unexpected drop in service; this is particulary important for applications unaware of \textsc{Citadel}.


\subsection{Additional Security Features}
\paragraph{} \textsc{Citadel} implements a handful of additional security mechanisms to reinforce potentially vulnerable aspects of the system. Both the policy enclave and LSM use a process's PID as its primary identifier --- \textsc{Citadel} implements two schemes to protect this notion of identity and help prove it.

\subsubsection{\textit{ptokens}}
\label{sec:ptokens}
\paragraph{} Before a process may interact with \texttt{citadeld}, it must retrieve its \textit{ptoken} from the LSM.\footnote{Read from \texttt{/sys/kernel/security/citadel/ptoken}} The purpose of this record (\ref{eqn:ptoken}) is twofold;
\begin{enumerate}
    \item[a.] Inform \texttt{libcitadel} about the process's metadata in the eyes of the LSM, and
    \item[b.] Provide an authenticable access token to present to \texttt{citadeld}, verifying the process's identity. This is AES encrypted using $K$, the system's designated static AES key, which is unknown to the process. 
\end{enumerate}

\vspace{-7mm}
\begin{align}
    \textit{ptoken} \rightarrow ( \text{citadel\_pid}, \text{identifier}, \text{token}, \{\text{identifier}, \text{token}, \text{pid}\}_K) \label{eqn:ptoken}
\end{align}

\paragraph{} Whenever a process connects to the \texttt{citadeld} socket, its identity is retrieved from the underlying transport mechanism. At both sender and receiver the identity of the other is verified using this method, and additionally \texttt{libcitadel} expects the decrypted \textit{token}, a randomly generated byte-array, to be returned by \texttt{citadeld},  inspiring confidence that the response has not been forged.

\begin{minted}[fontsize=\small]{c}
// Get PID of sender.
struct ucred cred;
socklen_t len = sizeof(struct ucred);
getsockopt(socket, SOL_SOCKET, SO_PEERCRED, (void*)&cred, &len);
uint64_t pid = cred.pid;
\end{minted}

\subsubsection{PID Protection}
\paragraph{} The LSM also implements a mechanism to detect PID forgery --- as shown in Appendix X, it is theoretically possible for a process to modify its PID with the help of a malicious kernel module. This, if unchecked, would be detrimental for the LSM's integrity, as it would allow a process to silently assume the identity of another. To this end, the LSM stores a process's PID within its security structure and routinely checks to ensure it does not change unexpectedly.\footnote{An expected change would be on \texttt{fork()}, in which case the stored PID should be that of the parent process.} Any process deemed to have an illegitimate PID is denied access to all entities, effectively killing it.

\subsection{\textsc{Citadel} Build System}
\label{sec:build-system}
\paragraph{}
